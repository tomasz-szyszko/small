{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Small C++ Small Containers Applications usually contain many auxiliary small data structures for each large collection of values. Container implementations often include several optimizations for the case when they are small. These optimizations cannot usually make it to the STL because of ABI compatibility issues. Users might need to reimplement these containers or rely on frameworks that include these implementations. Depending on large library collections for simple containers might impose a cost on the user that's higher than necessary and hinder collaboration on the evolution of these containers. This library includes independent implementations of the main STL containers optimized for the case when they are small.","title":"Home"},{"location":"#small","text":"C++ Small Containers Applications usually contain many auxiliary small data structures for each large collection of values. Container implementations often include several optimizations for the case when they are small. These optimizations cannot usually make it to the STL because of ABI compatibility issues. Users might need to reimplement these containers or rely on frameworks that include these implementations. Depending on large library collections for simple containers might impose a cost on the user that's higher than necessary and hinder collaboration on the evolution of these containers. This library includes independent implementations of the main STL containers optimized for the case when they are small.","title":"Small"},{"location":"quickstart/","text":"Quickstart Integration: CMake Add subdirectory 1 git clone https://github.com/alandefreitas/small/ 1 2 3 4 add_subdirectory ( small ) # ... add_executable ( your_target main.cpp ) target_link_libraries ( your_target PUBLIC small::small ) Fetch content 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 include ( FetchContent ) FetchContent_Declare ( small GIT_REPOSITORY https://github.com/alandefreitas/small GIT_TAG origin/master # or whatever tag you want ) FetchContent_GetProperties ( small ) if ( NOT small_POPULATED ) FetchContent_Populate ( small ) add_subdirectory ( ${ small_SOURCE_DIR } ${ small_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () # ... add_executable ( your_target main.cpp ) target_link_libraries ( your_target PUBLIC small::small ) External package 1 2 3 4 5 6 7 8 9 # Follow installation instructions and then... find_package ( small REQUIRED ) if ( NOT small_FOUND ) # Throw or put your FetchContent script here endif () # ... add_executable ( your_target main.cpp ) target_link_libraries ( your_target PUBLIC small::small ) Install Note Get the binary package from the release section . These binaries refer to the latest release version of small. Hint If you need a more recent version of small , you can download the binary packages from the CI artifacts or build the library from the source files. Build from source Note Ensure your C++ compiler and CMake are up-to-date and then: Ubuntu + GCC 1 2 3 4 5 6 7 8 9 10 11 # Create a new directory mkdir build cd build # Configure cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" # Build sudo cmake --build . --parallel 2 --config Release # Install sudo cmake --install . # Create packages sudo cpack . Mac Os + Clang 1 2 3 4 5 6 7 8 9 10 11 # Create a new directory mkdir build cd build # Configure cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" # Build cmake --build . --parallel 2 --config Release # Install cmake --install . # Create packages cpack . Windows + MSVC 1 2 3 4 5 6 7 8 9 10 11 # Create a new directory mkdir build cd build # Configure cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"/O2\" # Build cmake --build . --parallel 2 --config Release # Install cmake --install . # Create packages cpack . Parallel Build Replace --parallel 2 with --parallel <number of cores in your machine> Setting C++ Compiler If your C++ compiler that supports C++17 is not your default compiler, make sure you provide CMake with the compiler location with the DCMAKE_C_COMPILER and DCMAKE_CXX_COMPILER options. For instance: 1 cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DCMAKE_C_COMPILER = /usr/bin/gcc-8 -DCMAKE_CXX_COMPILER = /usr/bin/g++-8 File amalgamation Note Because containers are header-only, you can directly copy the contents from the source directory into your project. Hint In that case, you are responsible for setting the appropriate target include directories and any compile definitions you might require. Once the library is properly integrated, you can create containers from the namespace small like any other STL container: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/map.hpp> #include <small/queue.hpp> #include <small/set.hpp> #include <small/stack.hpp> #include <small/string.hpp> #include <small/vector.hpp> #include <iostream> template < class R > void print ( R && v ); void print_codepoints ( const small :: string & v ); int main () { // Vector as usual small :: vector < int > v1 = { 1 , 2 , 3 , 4 , 5 }; print ( v1 ); // 1 2 3 4 5 // Vector with inline storage for at least 10 elements small :: vector < int , 10 > v2 = { 1 , 2 , 3 , 4 }; v2 . push_back ( 5 ); print ( v2 ); // 1 2 3 4 5 // Vector with inline storage only small :: max_size_vector < int , 5 > v3 = { 1 , 2 , 3 , 4 }; v3 . push_back ( 5 ); print ( v3 ); // 1 2 3 4 5 // String small :: string s1 = \"Hello world!\" ; print ( s1 ); // H e l l o w o r l d ! // String with custom inline storage small :: basic_string < char , 40 > s2 = \"Hello world!\" ; print ( s2 ); // H e l l o w o r l d ! // UTF8 String from larger UTF-32 string small :: string s3 = U \"This works too! \ud83d\ude00 \u00e9!\" ; std :: cout << s3 << '\\n' ; // T h i s w o r k s t o o ! \ud83d\ude00 print_codepoints ( s3 ); // T|h|i|s| |w|o|r|k|s| |t|o|o|!| |\ud83d\ude00| | |\u00e9|!| // Associative containers small :: set < int > a1 = { 2 , 1 , 5 , 4 , 3 }; print ( a1 ); // 1 2 3 4 5 small :: map < int , int > a2 = { { 1 , 10 }, { 2 , 20 }, { 3 , 30 }, { 4 , 40 }, { 5 , 50 } }; print ( a2 ); // <1,10> <2,20> <3,30> <4,40> <5,50> small :: multimap < int , int > a3 = { { 1 , 10 }, { 1 , 20 }, { 1 , 30 }, { 1 , 40 }, { 1 , 50 } }; print ( a3 ); // <1,10> <1,20> <1,30> <1,40> <1,50> small :: unordered_set < int > a4 = { 2 , 1 , 5 , 4 , 3 }; print ( a4 ); // 2 1 5 4 3 // Container adaptors small :: stack < int > c1 ; c1 . push ( 1 ); c1 . push ( 2 ); c1 . push ( 3 ); c1 . push ( 4 ); c1 . push ( 5 ); std :: cout << c1 . top () << '\\n' ; // 5 small :: queue < int > c2 ; c2 . push ( 1 ); c2 . push ( 2 ); c2 . push ( 3 ); c2 . push ( 4 ); c2 . push ( 5 ); std :: cout << c2 . front () << '\\n' ; // 1 std :: cout << c2 . back () << '\\n' ; // 5 small :: priority_queue < int > c3 ; c3 . push ( 1 ); c3 . push ( 2 ); c3 . push ( 3 ); c3 . push ( 4 ); c3 . push ( 5 ); std :: cout << c3 . top () << '\\n' ; // 5 return 0 ; } template < class R > void print ( R && v ) { for ( const auto & x : v ) { constexpr bool x_is_pair = small :: detail :: is_pair_v < std :: decay_t < decltype ( x ) >> ; if constexpr ( not x_is_pair ) { std :: cout << x << ' ' ; } else { std :: cout << '<' << x . first << ',' << x . second << '>' << ' ' ; } } std :: cout << \" \\n \" ; } void print_codepoints ( const small :: string & v ) { for ( auto it = v . begin_codepoint (); it != v . end_codepoint (); ++ it ) { std :: cout << * it << '|' ; } std :: cout << \" \\n \" ; } All containers are optimized for the case when they're small but also efficient when they are large. The containers mix the common techniques found in other small container libraries: Inline allocation for small containers Custom expected sizes Identification of relocatable types Custom growth factors with better defaults Communication with system memory allocators Explicit consideration of CPU cache sizes and branch prediction Most applications have many small lists and sets of elements. These containers avoid spending a lot of time with large containers that contain just a few elements. Small containers usually try to use the stack before dynamically allocating memory and try to represent associative containers with stack arrays, unless these sets are very large. The following containers are available: small::vector small::max_size_vector small::string small::set small::max_size_set small::multiset small::max_size_multiset small::unordered_set small::max_size_unordered_set small::unordered_multiset small::max_size_unordered_multiset small::map small::max_size_map small::multimap small::max_size_multimap small::unordered_map small::max_size_unordered_map small::unordered_multimap small::max_size_unordered_multimap small::stack small::queue small::priority_queue Although many compilers support small string optimization (SSO) already, this library will ensure all strings support SOO, custom inline sizes, relocation, and unicode.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Integration: CMake Add subdirectory 1 git clone https://github.com/alandefreitas/small/ 1 2 3 4 add_subdirectory ( small ) # ... add_executable ( your_target main.cpp ) target_link_libraries ( your_target PUBLIC small::small ) Fetch content 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 include ( FetchContent ) FetchContent_Declare ( small GIT_REPOSITORY https://github.com/alandefreitas/small GIT_TAG origin/master # or whatever tag you want ) FetchContent_GetProperties ( small ) if ( NOT small_POPULATED ) FetchContent_Populate ( small ) add_subdirectory ( ${ small_SOURCE_DIR } ${ small_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () # ... add_executable ( your_target main.cpp ) target_link_libraries ( your_target PUBLIC small::small ) External package 1 2 3 4 5 6 7 8 9 # Follow installation instructions and then... find_package ( small REQUIRED ) if ( NOT small_FOUND ) # Throw or put your FetchContent script here endif () # ... add_executable ( your_target main.cpp ) target_link_libraries ( your_target PUBLIC small::small ) Install Note Get the binary package from the release section . These binaries refer to the latest release version of small. Hint If you need a more recent version of small , you can download the binary packages from the CI artifacts or build the library from the source files. Build from source Note Ensure your C++ compiler and CMake are up-to-date and then: Ubuntu + GCC 1 2 3 4 5 6 7 8 9 10 11 # Create a new directory mkdir build cd build # Configure cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" # Build sudo cmake --build . --parallel 2 --config Release # Install sudo cmake --install . # Create packages sudo cpack . Mac Os + Clang 1 2 3 4 5 6 7 8 9 10 11 # Create a new directory mkdir build cd build # Configure cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" # Build cmake --build . --parallel 2 --config Release # Install cmake --install . # Create packages cpack . Windows + MSVC 1 2 3 4 5 6 7 8 9 10 11 # Create a new directory mkdir build cd build # Configure cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"/O2\" # Build cmake --build . --parallel 2 --config Release # Install cmake --install . # Create packages cpack . Parallel Build Replace --parallel 2 with --parallel <number of cores in your machine> Setting C++ Compiler If your C++ compiler that supports C++17 is not your default compiler, make sure you provide CMake with the compiler location with the DCMAKE_C_COMPILER and DCMAKE_CXX_COMPILER options. For instance: 1 cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DCMAKE_C_COMPILER = /usr/bin/gcc-8 -DCMAKE_CXX_COMPILER = /usr/bin/g++-8 File amalgamation Note Because containers are header-only, you can directly copy the contents from the source directory into your project. Hint In that case, you are responsible for setting the appropriate target include directories and any compile definitions you might require. Once the library is properly integrated, you can create containers from the namespace small like any other STL container: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/map.hpp> #include <small/queue.hpp> #include <small/set.hpp> #include <small/stack.hpp> #include <small/string.hpp> #include <small/vector.hpp> #include <iostream> template < class R > void print ( R && v ); void print_codepoints ( const small :: string & v ); int main () { // Vector as usual small :: vector < int > v1 = { 1 , 2 , 3 , 4 , 5 }; print ( v1 ); // 1 2 3 4 5 // Vector with inline storage for at least 10 elements small :: vector < int , 10 > v2 = { 1 , 2 , 3 , 4 }; v2 . push_back ( 5 ); print ( v2 ); // 1 2 3 4 5 // Vector with inline storage only small :: max_size_vector < int , 5 > v3 = { 1 , 2 , 3 , 4 }; v3 . push_back ( 5 ); print ( v3 ); // 1 2 3 4 5 // String small :: string s1 = \"Hello world!\" ; print ( s1 ); // H e l l o w o r l d ! // String with custom inline storage small :: basic_string < char , 40 > s2 = \"Hello world!\" ; print ( s2 ); // H e l l o w o r l d ! // UTF8 String from larger UTF-32 string small :: string s3 = U \"This works too! \ud83d\ude00 \u00e9!\" ; std :: cout << s3 << '\\n' ; // T h i s w o r k s t o o ! \ud83d\ude00 print_codepoints ( s3 ); // T|h|i|s| |w|o|r|k|s| |t|o|o|!| |\ud83d\ude00| | |\u00e9|!| // Associative containers small :: set < int > a1 = { 2 , 1 , 5 , 4 , 3 }; print ( a1 ); // 1 2 3 4 5 small :: map < int , int > a2 = { { 1 , 10 }, { 2 , 20 }, { 3 , 30 }, { 4 , 40 }, { 5 , 50 } }; print ( a2 ); // <1,10> <2,20> <3,30> <4,40> <5,50> small :: multimap < int , int > a3 = { { 1 , 10 }, { 1 , 20 }, { 1 , 30 }, { 1 , 40 }, { 1 , 50 } }; print ( a3 ); // <1,10> <1,20> <1,30> <1,40> <1,50> small :: unordered_set < int > a4 = { 2 , 1 , 5 , 4 , 3 }; print ( a4 ); // 2 1 5 4 3 // Container adaptors small :: stack < int > c1 ; c1 . push ( 1 ); c1 . push ( 2 ); c1 . push ( 3 ); c1 . push ( 4 ); c1 . push ( 5 ); std :: cout << c1 . top () << '\\n' ; // 5 small :: queue < int > c2 ; c2 . push ( 1 ); c2 . push ( 2 ); c2 . push ( 3 ); c2 . push ( 4 ); c2 . push ( 5 ); std :: cout << c2 . front () << '\\n' ; // 1 std :: cout << c2 . back () << '\\n' ; // 5 small :: priority_queue < int > c3 ; c3 . push ( 1 ); c3 . push ( 2 ); c3 . push ( 3 ); c3 . push ( 4 ); c3 . push ( 5 ); std :: cout << c3 . top () << '\\n' ; // 5 return 0 ; } template < class R > void print ( R && v ) { for ( const auto & x : v ) { constexpr bool x_is_pair = small :: detail :: is_pair_v < std :: decay_t < decltype ( x ) >> ; if constexpr ( not x_is_pair ) { std :: cout << x << ' ' ; } else { std :: cout << '<' << x . first << ',' << x . second << '>' << ' ' ; } } std :: cout << \" \\n \" ; } void print_codepoints ( const small :: string & v ) { for ( auto it = v . begin_codepoint (); it != v . end_codepoint (); ++ it ) { std :: cout << * it << '|' ; } std :: cout << \" \\n \" ; } All containers are optimized for the case when they're small but also efficient when they are large. The containers mix the common techniques found in other small container libraries: Inline allocation for small containers Custom expected sizes Identification of relocatable types Custom growth factors with better defaults Communication with system memory allocators Explicit consideration of CPU cache sizes and branch prediction Most applications have many small lists and sets of elements. These containers avoid spending a lot of time with large containers that contain just a few elements. Small containers usually try to use the stack before dynamically allocating memory and try to represent associative containers with stack arrays, unless these sets are very large. The following containers are available: small::vector small::max_size_vector small::string small::set small::max_size_set small::multiset small::max_size_multiset small::unordered_set small::max_size_unordered_set small::unordered_multiset small::max_size_unordered_multiset small::map small::max_size_map small::multimap small::max_size_multimap small::unordered_map small::max_size_unordered_map small::unordered_multimap small::max_size_unordered_multimap small::stack small::queue small::priority_queue Although many compilers support small string optimization (SSO) already, this library will ensure all strings support SOO, custom inline sizes, relocation, and unicode.","title":"Quickstart"},{"location":"references/","text":"References These are some references we used for this work: Abseil Folly LLVM Boost Containers Tiny-utf8","title":"References"},{"location":"references/#references","text":"These are some references we used for this work: Abseil Folly LLVM Boost Containers Tiny-utf8","title":"References"},{"location":"sets-and-maps/","text":"Sets and Maps The small set/map classes use a more cache-friendly flat set/map and all other optimizations mentioned above for internal algorithms. As with other small containers, a custom template parameter can be used to define the number of inline elements in the container. The small::default_inline_storage and small::is_relocatable trait can also be defined for custom types, and all the usual set/map, ordered/unordered, uni/multi variants are also provided: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/map.hpp> #include <small/set.hpp> #include <iostream> // A relocatable custom type whose default inline storage should be at least 10 // elements struct my_type { int a ; double b ; friend bool operator < ( const my_type & lhs , const my_type & rhs ) { return lhs . a < rhs . a ; } }; namespace small { template <> struct is_relocatable < my_type > : std :: true_type {}; template <> struct default_inline_storage < my_type > : std :: integral_constant < size_t , 10 > {}; } // namespace small int main () { // Inline storage for at least 5 elements small :: max_size_map < int , my_type , 5 > v1 = { { 1 , { 1 , 1.1 }}, { 2 , { 2 , 2.2 }}, { 3 , { 3 , 3.3 }}, { 4 , { 4 , 4.4 }}, { 5 , { 5 , 5.5 }} }; for ( const auto & x : v1 ) { std :: cout << '<' << x . first << ',' << '<' << x . second . a << ',' << x . second . b << '>' << '>' << ' ' ; } std :: cout << \" \\n \" ; // Default inline storage for at least 10 elements small :: unordered_multiset < my_type > v2 = { { 1 , 1.1 }, { 2 , 2.2 }, { 3 , 3.3 }, { 4 , 4.4 }, { 5 , 5.5 } }; for ( const auto & x : v2 ) { std :: cout << '<' << x . a << ',' << x . b << '>' << ' ' ; } std :: cout << \" \\n \" ; return 0 ; } Unlike a small::vector or small::string , the asymptotic time complexities of flat sets/maps are very different from their std:: counterparts and should only be used when they are small. Because they are internally implemented as arrays, manipulating these containers costs O(n) . For large containers, you can use std containers with custom allocators. Or for efficient large containers, you can use the abseil containers, implemented as B+-trees.","title":"Sets and Maps"},{"location":"sets-and-maps/#sets-and-maps","text":"The small set/map classes use a more cache-friendly flat set/map and all other optimizations mentioned above for internal algorithms. As with other small containers, a custom template parameter can be used to define the number of inline elements in the container. The small::default_inline_storage and small::is_relocatable trait can also be defined for custom types, and all the usual set/map, ordered/unordered, uni/multi variants are also provided: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/map.hpp> #include <small/set.hpp> #include <iostream> // A relocatable custom type whose default inline storage should be at least 10 // elements struct my_type { int a ; double b ; friend bool operator < ( const my_type & lhs , const my_type & rhs ) { return lhs . a < rhs . a ; } }; namespace small { template <> struct is_relocatable < my_type > : std :: true_type {}; template <> struct default_inline_storage < my_type > : std :: integral_constant < size_t , 10 > {}; } // namespace small int main () { // Inline storage for at least 5 elements small :: max_size_map < int , my_type , 5 > v1 = { { 1 , { 1 , 1.1 }}, { 2 , { 2 , 2.2 }}, { 3 , { 3 , 3.3 }}, { 4 , { 4 , 4.4 }}, { 5 , { 5 , 5.5 }} }; for ( const auto & x : v1 ) { std :: cout << '<' << x . first << ',' << '<' << x . second . a << ',' << x . second . b << '>' << '>' << ' ' ; } std :: cout << \" \\n \" ; // Default inline storage for at least 10 elements small :: unordered_multiset < my_type > v2 = { { 1 , 1.1 }, { 2 , 2.2 }, { 3 , 3.3 }, { 4 , 4.4 }, { 5 , 5.5 } }; for ( const auto & x : v2 ) { std :: cout << '<' << x . a << ',' << x . b << '>' << ' ' ; } std :: cout << \" \\n \" ; return 0 ; } Unlike a small::vector or small::string , the asymptotic time complexities of flat sets/maps are very different from their std:: counterparts and should only be used when they are small. Because they are internally implemented as arrays, manipulating these containers costs O(n) . For large containers, you can use std containers with custom allocators. Or for efficient large containers, you can use the abseil containers, implemented as B+-trees.","title":"Sets and Maps"},{"location":"strings/","text":"Strings The small string includes all the common optimizations for small vectors, and a custom template parameter to set how large we expect the string to be (in bytes). However, when strings are representing text, if there's one thing that makes them not small is not supporting UTF8. In addition to the common interface for strings, small::string includes extra functions to identify and work with UTF8 code points with random access. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/string.hpp> #include <iostream> int main () { // Input is UTF32, but string stores it as UTF8 small :: string str = U \"Hello \ud83c\udf0e!\" ; // Accessing bytes std :: cout << static_cast < char > ( str [ 4 ]) << '\\n' ; // o std :: cout << static_cast < char > ( str [ 6 ]) << '\\n' ; // \ufffd // Accessing codepoints using cp_idx = small :: string :: codepoint_index ; std :: cout << str [ cp_idx ( 4 )] << '\\n' ; // o std :: cout << str [ cp_idx ( 6 )] << '\\n' ; // \ud83c\udf0e // Malformed unicode strings assert ( not small :: is_malformed ( str )); str [ 7 ] = 'a' ; assert ( small :: is_malformed ( str )); return 0 ; } The problem of supporting UTF8 is easier to explain than it is to solve. Programming languages tend to solve this problem by (1) forbidding byte or substring access, and/or (2) allowing only access to code points with O(n) cost, where n is the number of code points. Because anything that forbids byte access would be incompatible with a C++ string, we allow direct byte access, and strings are allowed to be malformed unicode, which we can check with small::is_malformed . All capacity and access functions contain extra overloads that accept codepoint indexes, defined as a strong type, rather than byte indexes. By using these functions, one can ensure the string is never malformed. It's up to the user to decide whether these access functions are useful and worth it in a particular application. Access to codepoints is provided with an inline lookup-table trick that allows us to access codepoints in O(log m) time, where m is the number of multibyte code points in the strings. When there are no multibyte codepoints in the string, the string works as usual and no extra memory is required for the table.","title":"Strings"},{"location":"strings/#strings","text":"The small string includes all the common optimizations for small vectors, and a custom template parameter to set how large we expect the string to be (in bytes). However, when strings are representing text, if there's one thing that makes them not small is not supporting UTF8. In addition to the common interface for strings, small::string includes extra functions to identify and work with UTF8 code points with random access. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/string.hpp> #include <iostream> int main () { // Input is UTF32, but string stores it as UTF8 small :: string str = U \"Hello \ud83c\udf0e!\" ; // Accessing bytes std :: cout << static_cast < char > ( str [ 4 ]) << '\\n' ; // o std :: cout << static_cast < char > ( str [ 6 ]) << '\\n' ; // \ufffd // Accessing codepoints using cp_idx = small :: string :: codepoint_index ; std :: cout << str [ cp_idx ( 4 )] << '\\n' ; // o std :: cout << str [ cp_idx ( 6 )] << '\\n' ; // \ud83c\udf0e // Malformed unicode strings assert ( not small :: is_malformed ( str )); str [ 7 ] = 'a' ; assert ( small :: is_malformed ( str )); return 0 ; } The problem of supporting UTF8 is easier to explain than it is to solve. Programming languages tend to solve this problem by (1) forbidding byte or substring access, and/or (2) allowing only access to code points with O(n) cost, where n is the number of code points. Because anything that forbids byte access would be incompatible with a C++ string, we allow direct byte access, and strings are allowed to be malformed unicode, which we can check with small::is_malformed . All capacity and access functions contain extra overloads that accept codepoint indexes, defined as a strong type, rather than byte indexes. By using these functions, one can ensure the string is never malformed. It's up to the user to decide whether these access functions are useful and worth it in a particular application. Access to codepoints is provided with an inline lookup-table trick that allows us to access codepoints in O(log m) time, where m is the number of multibyte code points in the strings. When there are no multibyte codepoints in the string, the string works as usual and no extra memory is required for the table.","title":"Strings"},{"location":"vectors/","text":"Vectors This small vector implementation includes: Inline allocation for small vectors Custom expected size Special treatment of relocatable types Relocatable types can be moved with memcpy , bypassing destructors and constructors. Relocatable types are defined by default for POD types and aggregate types of PODs The small::is_relocatable traits can be used as an extension point for custom types Better growth factors Consider the cache line size in allocations Heap allocations can be disabled with small::max_size_vector When there are fewer elements than a given threshold, the elements are kept in a stack buffer for small vectors. Otherwise, the vector works as usual. However, if you are 100% sure you will never need more than N elements, you can use a max_size_vector , where elements are always inline. The default number of elements in a small vector is usually the number of elements we can already fit inline in a vector. For larger data types, the default_inline_storage trait can be used as an extension point where one can define how many elements a small vector of that type should contain by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/vector.hpp> #include <iostream> // A relocatable custom type whose default inline storage should be at least 10 // elements struct my_type { int a ; double b ; }; namespace small { template <> struct is_relocatable < my_type > : std :: true_type {}; template <> struct default_inline_storage < my_type > : std :: integral_constant < size_t , 10 > {}; } // namespace small int main () { // Inline storage for at least 5 elements small :: vector < my_type , 5 > v1 = { { 1 , 1.1 }, { 2 , 2.2 }, { 3 , 3.3 }, { 4 , 4.4 }, { 5 , 5.5 } }; for ( const auto & x : v1 ) { std :: cout << '<' << x . a << ',' << x . b << '>' << ' ' ; } std :: cout << \" \\n \" ; // <1,1.1> <2,2.2> <3,3.3> <4,4.4> <5,5.5> // Default inline storage for at least 10 elements small :: vector < my_type > v2 = { { 1 , 1.1 }, { 2 , 2.2 }, { 3 , 3.3 }, { 4 , 4.4 }, { 5 , 5.5 } }; for ( const auto & x : v2 ) { std :: cout << '<' << x . a << ',' << x . b << '>' << ' ' ; } std :: cout << \" \\n \" ; // <1,1.1> <2,2.2> <3,3.3> <4,4.4> <5,5.5> return 0 ; } When there's a reasonable default for the number of inline elements, this strategy avoids multiple vector type instantiations for different inline storage sizes. This small vector implementation used folly, abseil, and LLVM as a reference.","title":"Vectors"},{"location":"vectors/#vectors","text":"This small vector implementation includes: Inline allocation for small vectors Custom expected size Special treatment of relocatable types Relocatable types can be moved with memcpy , bypassing destructors and constructors. Relocatable types are defined by default for POD types and aggregate types of PODs The small::is_relocatable traits can be used as an extension point for custom types Better growth factors Consider the cache line size in allocations Heap allocations can be disabled with small::max_size_vector When there are fewer elements than a given threshold, the elements are kept in a stack buffer for small vectors. Otherwise, the vector works as usual. However, if you are 100% sure you will never need more than N elements, you can use a max_size_vector , where elements are always inline. The default number of elements in a small vector is usually the number of elements we can already fit inline in a vector. For larger data types, the default_inline_storage trait can be used as an extension point where one can define how many elements a small vector of that type should contain by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #include <small/vector.hpp> #include <iostream> // A relocatable custom type whose default inline storage should be at least 10 // elements struct my_type { int a ; double b ; }; namespace small { template <> struct is_relocatable < my_type > : std :: true_type {}; template <> struct default_inline_storage < my_type > : std :: integral_constant < size_t , 10 > {}; } // namespace small int main () { // Inline storage for at least 5 elements small :: vector < my_type , 5 > v1 = { { 1 , 1.1 }, { 2 , 2.2 }, { 3 , 3.3 }, { 4 , 4.4 }, { 5 , 5.5 } }; for ( const auto & x : v1 ) { std :: cout << '<' << x . a << ',' << x . b << '>' << ' ' ; } std :: cout << \" \\n \" ; // <1,1.1> <2,2.2> <3,3.3> <4,4.4> <5,5.5> // Default inline storage for at least 10 elements small :: vector < my_type > v2 = { { 1 , 1.1 }, { 2 , 2.2 }, { 3 , 3.3 }, { 4 , 4.4 }, { 5 , 5.5 } }; for ( const auto & x : v2 ) { std :: cout << '<' << x . a << ',' << x . b << '>' << ' ' ; } std :: cout << \" \\n \" ; // <1,1.1> <2,2.2> <3,3.3> <4,4.4> <5,5.5> return 0 ; } When there's a reasonable default for the number of inline elements, this strategy avoids multiple vector type instantiations for different inline storage sizes. This small vector implementation used folly, abseil, and LLVM as a reference.","title":"Vectors"},{"location":"contributing/contributors/","text":"Contributors Marcos Pontes Alan De Freitas","title":"Contributors"},{"location":"contributing/contributors/#contributors","text":"Marcos Pontes Alan De Freitas","title":"Contributors"},{"location":"contributing/get-involved/","text":"Get Involved Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. It'd be great to see this library help people write papers.","title":"Get Involved"},{"location":"contributing/get-involved/#get-involved","text":"Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. It'd be great to see this library help people write papers.","title":"Get Involved"},{"location":"contributing/guidelines/","text":"Guidelines If contributing with code, please leave all warnings ON ( -DSMALL_BUILD_WITH_PEDANTIC_WARNINGS=ON ), use cppcheck , and clang-format . If contributing to the documentation, please edit README.md directly, as the files in ./docs are automatically generated with mdsplit .","title":"Guidelines"},{"location":"contributing/guidelines/#guidelines","text":"If contributing with code, please leave all warnings ON ( -DSMALL_BUILD_WITH_PEDANTIC_WARNINGS=ON ), use cppcheck , and clang-format . If contributing to the documentation, please edit README.md directly, as the files in ./docs are automatically generated with mdsplit .","title":"Guidelines"},{"location":"contributing/ideas-and-roadmap/","text":"Ideas and Roadmap Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Finding problems in this documentation see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature, so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Ideas and Roadmap"},{"location":"contributing/ideas-and-roadmap/#ideas-and-roadmap","text":"Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Finding problems in this documentation see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature, so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Ideas and Roadmap"}]}